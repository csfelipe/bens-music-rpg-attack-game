<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music RPG Attack Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameCanvas {
            border: 2px solid #ffd700;
            background: #000;
            display: block;
        }

        .screen {
            position: absolute;
            width: 800px;
            height: 600px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 50px;
            overflow-y: auto;
        }

        .screen.active {
            display: flex;
        }

        h1 {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #titleScreen {
            justify-content: flex-start;
            padding-top: 30px;
        }
        
        #titleButtons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            max-height: 400px;
        }

        h2 {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
        }

        button {
            background: #333;
            color: #ffd700;
            border: 2px solid #ffd700;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        button:hover {
            background: #ffd700;
            color: #000;
        }

        button.selected {
            background: #ffd700;
            color: #000;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
            max-width: 700px;
        }

        .character-card {
            background: #222;
            border: 2px solid #666;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .character-card:hover {
            border-color: #ffd700;
        }

        .character-card.selected {
            border-color: #ffd700;
            background: #333;
        }

        .character-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .difficulty-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }

        .difficulty-item {
            background: #222;
            border: 2px solid #666;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .difficulty-item:hover {
            border-color: #ffd700;
        }

        .difficulty-item.selected {
            border-color: #ffd700;
            background: #333;
        }

        .battle-screen {
            background: #228b22;
            position: relative;
            overflow: hidden;
        }

        .battle-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 100%;
            padding: 20px;
            width: 100%;
        }

        .character-battle {
            text-align: center;
            width: 45%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .character-sprite {
            width: 150px;
            height: 200px;
            position: relative;
            margin: 20px 0;
        }

        .health-bar-container {
            width: 200px;
            height: 25px;
            background: #000;
            border: 2px solid #fff;
            margin: 10px auto;
            position: relative;
        }

        .health-bar {
            height: 100%;
            background: #ff0000;
            transition: width 0.3s;
            min-width: 0;
        }
        
        .health-bar-label {
            position: absolute;
            top: -25px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: #fff;
        }

        .move-menu {
            position: absolute;
            top: 200px;
            right: 50px;
            background: #222;
            border: 3px solid #ffd700;
            padding: 20px;
            min-width: 300px;
            max-width: 350px;
            z-index: 10;
        }

        .move-item {
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            background: #333;
            border: 2px solid #666;
        }

        .move-item:hover, .move-item.selected {
            border-color: #ffd700;
            background: #444;
        }

        .question-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .question-box {
            background: #222;
            border: 4px solid #ffd700;
            padding: 30px;
            max-width: 700px;
            text-align: center;
        }

        .staff {
            margin: 20px 0;
            position: relative;
            height: 60px;
        }

        .staff-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: #fff;
        }

        .note {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #000;
        }

        .note.circled {
            border: 3px solid #ffd700;
            box-shadow: 0 0 10px #ffd700;
        }

        input[type="text"] {
            background: #000;
            color: #ffd700;
            border: 2px solid #ffd700;
            padding: 10px;
            font-size: 18px;
            margin: 10px;
            text-align: center;
        }

        .battle-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border: 2px solid #ffd700;
            font-size: 18px;
            color: #fff;
            z-index: 10;
            border-radius: 5px;
        }

        .win-lose-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .win-lose-text {
            font-size: 72px;
            margin-bottom: 30px;
        }

        .win {
            color: #ffd700;
        }

        .lose {
            color: #ff0000;
        }

        .instructions {
            font-size: 14px;
            color: #aaa;
            margin-top: 20px;
            text-align: center;
        }

        .achievement-list {
            list-style: none;
            margin: 20px 0;
        }

        .achievement-item {
            padding: 10px;
            margin: 5px 0;
            background: #222;
            border-left: 4px solid #666;
        }

        .achievement-item.unlocked {
            border-left-color: #ffd700;
        }

        .countdown {
            font-size: 36px;
            color: #fff;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- Title Screen -->
    <div id="titleScreen" class="screen active">
        <h1>Music RPG Attack Game</h1>
        <div class="countdown" id="countdown"></div>
        <div id="timeUpMessage" style="display: none;">
            <h2>Time's Up!</h2>
        </div>
        <div id="titleButtons" style="display: none; flex-direction: column; align-items: center; gap: 10px;">
            <button onclick="game.showCharacterSelect()">Start</button>
            <button onclick="game.showAchievements()">Achievements</button>
            <button onclick="game.saveGame()">Save Game</button>
            <button onclick="game.loadGame()">Load Game</button>
        </div>
    </div>

    <!-- Character Select Screen -->
    <div id="characterSelectScreen" class="screen">
        <h2>Select Character</h2>
        <div class="character-grid" id="characterGrid"></div>
        <div class="instructions">Arrow Keys: Navigate | Enter: Select | ESC: Back to Title</div>
    </div>

    <!-- NPC Select Screen -->
    <div id="npcSelectScreen" class="screen">
        <h2>Select NPC Character</h2>
        <div class="character-grid" id="npcGrid"></div>
        <div class="instructions">Arrow Keys: Navigate | Enter: Select | ESC: Back</div>
    </div>

    <!-- Difficulty Select Screen -->
    <div id="difficultySelectScreen" class="screen">
        <h2>Select Difficulty</h2>
        <div class="difficulty-list" id="difficultyList"></div>
        <div class="instructions">Arrow Keys: Navigate | Enter: Select | ESC: Back</div>
    </div>

    <!-- Battle Screen -->
    <div id="battleScreen" class="screen battle-screen" tabindex="0">
        <div class="battle-area">
            <div class="character-battle" style="align-items: flex-start; padding-top: 50px;">
                <div style="font-size: 20px; color: #fff; margin-bottom: 10px;">Player</div>
                <div id="playerCharacter"></div>
                <div style="font-size: 14px; color: #fff; margin-top: 10px;">HP</div>
                <div id="playerHealthBar" class="health-bar-container">
                    <div id="playerHealth" class="health-bar"></div>
                </div>
                <div id="playerStats"></div>
            </div>
            <div class="character-battle" style="align-items: flex-start; padding-top: 50px;">
                <div style="font-size: 20px; color: #fff; margin-bottom: 10px;">Enemy</div>
                <div id="npcCharacter"></div>
                <div style="font-size: 14px; color: #fff; margin-top: 10px;">HP</div>
                <div id="npcHealthBar" class="health-bar-container">
                    <div id="npcHealth" class="health-bar"></div>
                </div>
                <div id="npcStats"></div>
            </div>
        </div>
        <div id="battleMessage" class="battle-message"></div>
        <button id="showMoveButton" onclick="game.showMoveMenu()" style="position: absolute; top: 150px; right: 50px; background: #ffd700; color: #000; border: 2px solid #fff; padding: 15px 30px; font-size: 18px; cursor: pointer; display: none; z-index: 10;">Select Move</button>
        <div id="moveMenu" class="move-menu" style="display: none;">
            <h3 style="color: #ffd700; margin-bottom: 10px;">Select Move:</h3>
            <div id="moveList"></div>
            <div class="instructions">1/2/3 or Arrow Keys + Enter | ESC to cancel</div>
        </div>
        <div id="questionOverlay" class="question-overlay" style="display: none;">
            <div class="question-box">
                <h3 style="color: #ffd700;">SUPER MOVE - Music Question</h3>
                <div id="questionText"></div>
                <div id="staffContainer" class="staff"></div>
                <div>
                    <label>Your answer:</label>
                    <input type="text" id="answerInput" maxlength="2" />
                    <button onclick="game.submitAnswer()">Submit</button>
                </div>
            </div>
        </div>
        <div id="winLoseOverlay" class="win-lose-overlay" style="display: none;">
            <div id="winLoseText" class="win-lose-text"></div>
            <div id="winLoseMessage"></div>
            <button onclick="game.handleBattleEnd()">Continue</button>
        </div>
    </div>

    <!-- Achievements Screen -->
    <div id="achievementsScreen" class="screen">
        <h2>Achievements</h2>
        <ul class="achievement-list" id="achievementList"></ul>
        <div class="instructions">Press ESC to return</div>
    </div>

    <!-- Audio element for boss music -->
    <audio id="bossMusic" loop>
        <source src="" type="audio/mpeg">
    </audio>

    <script>
        // Game state
        const game = {
            // Constants
            SCREEN_WIDTH: 800,
            SCREEN_HEIGHT: 600,
            targetDate: new Date('2026-01-16T03:50:00'),
            
            // State
            currentScreen: 'title',
            showTimeUpMessage: false,
            timeUpMessageStart: null,
            
            // Achievements
            achievements: {
                win: {name: "Win", description: "Win a game", unlocked: false},
                pay_taxes: {name: "Now you have to pay your taxes", description: "Lose a game", unlocked: false},
                why: {name: "Why", description: "Win as the character", unlocked: false},
                tune_i_love: {name: "That the tune i love", description: "Win as Saxophone with under 50% health", unlocked: false},
                bird_plane: {name: "It bird it a plane what nooooooo", description: "Win without using super moves", unlocked: false},
                good_show: {name: "A Good Show", description: "Win a mirror match on Expert difficulty", unlocked: false},
            },
            
            // Characters
            characters: [
                {name: "Flute", color: "#ffffff", speed: 10, weight: 1, base_hp: 70, base_damage: 6},
                {name: "Clarinet", color: "#ffd700", speed: 8, weight: 2, base_hp: 80, base_damage: 7},
                {name: "Saxophone", color: "#6496ff", speed: 6, weight: 4, base_hp: 90, base_damage: 8},
                {name: "Trombone", color: "#ffd700", speed: 4, weight: 6, base_hp: 110, base_damage: 10},
                {name: "Baritone", color: "#ffffff", speed: 3, weight: 8, base_hp: 120, base_damage: 11},
                {name: "Tuba", color: "#6496ff", speed: 2, weight: 10, base_hp: 130, base_damage: 12},
                {name: "Mafeoso", color: "#ffd700", speed: 7, weight: 5, base_hp: 200, base_damage: 14, unlocked: false},
                {name: "Artful", color: "#000000", speed: 5, weight: 5, base_hp: 150, base_damage: 25, unlocked: false},
            ],
            
            selectedCharacterIndex: 0,
            selectedCharacter: null,
            selectedNpcIndex: 0,
            selectedNpc: null,
            selectedDifficultyIndex: 0,
            selectedDifficulty: null,
            
            difficulties: ["Easy", "Medium", "Hard", "Expert", "Teacher Mode", "Boss Rush"],
            teacherMode: false,
            teacherBattleCount: 0,
            teacherMaxBattles: 3,
            
            // Boss Rush mode
            bossRushMode: false,
            currentBossIndex: 0,
            totalBosses: 4,
            bosses: [
                // Boss 1 - Dark checkerboard figure with spiky hands and candy necklace
                {name: "The Shadow", color: "#333333", speed: 5, weight: 5, base_hp: 300, base_damage: 10, description: "A dark, menacing figure with spiky hands", musicFile: "FF9CAE (Color and Electricity c00lkidd) __ FORSAKEN OST.mp3"},
                // Boss 2 - Yellow/orange blocky robot with glowing aura
                {name: "Harken", color: "#ffd700", speed: 6, weight: 4, base_hp: 400, base_damage: 20, description: "A bright blocky construct of energy", musicFile: "Hark, The _Angel_ Bleeds. - Die Of Death OST (Harken's Theme).mp3"},
                // Boss 3 - Sans (1 HP, 99% dodge chance)
                {name: "Sans", color: "#ffffff", speed: 10, weight: 1, base_hp: 1, base_damage: 15, description: "A skeleton with incredible dodging ability", musicFile: "MEGALOVANIA 4.mp3", hasDodge: true, dodgeChance: 0.99},
                // Boss 4 - Purple alien creature with pink tentacles and long blue legs
                {name: "Kinito", color: "#dda0dd", speed: 7, weight: 3, base_hp: 555, base_damage: 15, description: "A whimsical alien creature", musicFile: "【KinitoPET Song】 Best Friends by  _@OR3Omusic_.mp3"},
            ],
            
            // Battle state
            inBattle: false,
            playerHealth: 100,
            playerMaxHealth: 100,
            npcHealth: 100,
            npcMaxHealth: 100,
            playerTurn: true,
            battleMessage: "",
            battleMessageTimer: 0,
            showMoveSelection: false,
            selectedMoveIndex: 0,
            battleOver: false,
            battleResult: null,
            
            // Moves
            moves: [
                {name: "Normal Attack", type: "attack", damage_multiplier: 1.0, description: "Standard attack"},
                {name: "Block", type: "block", damage_multiplier: 0.0, description: "Defend against next attack"},
                {name: "Super", type: "super", damage_multiplier: 2.0, description: "Answer music question for big damage"},
            ],
            
            // Music questions
            musicNotes: ["C", "D", "E", "F", "G", "A", "B"],
            currentQuestion: null,
            questionAnswer: "",
            showQuestion: false,
            
            // Multi-hit system
            attackHits: [],
            currentHitIndex: 0,
            
            // Blocking
            playerBlocking: false,
            npcBlocking: false,
            
            // NPC AI
            npcMoveSelection: null,
            npcLastActionTime: 0,
            npcNextReactionTime: 0,
            
            // Tracking
            superMovesUsedThisBattle: 0,
            blocksUsed: 0,
            
            // Teacher mode learning
            learnedPlayerPatterns: {
                preferred_moves: {attack: 0, block: 0, super: 0},
                move_sequences: [],
                health_thresholds: {low: [], medium: [], high: []},
                block_usage: 0,
                super_usage: 0,
            },
            currentBattleMoves: [],
            
            // Initialize
            init() {
                this.updateCountdown();
                setInterval(() => this.updateCountdown(), 1000);
                setTimeout(() => {
                    document.getElementById('titleButtons').style.display = 'flex';
                }, 1000);
                this.setupKeyboard();
                this.renderCharacterSelect();
                this.renderNpcSelect();
                this.renderDifficultySelect();
                this.renderAchievements();
                // Try to load saved game on startup
                this.loadGame();
            },
            
            // Save/Load system
            saveGame(showAlert = true) {
                try {
                    const saveData = {
                        achievements: this.achievements,
                        characters: this.characters.map(char => ({
                            name: char.name,
                            unlocked: char.unlocked !== undefined ? char.unlocked : true
                        })),
                        saveDate: new Date().toISOString()
                    };
                    localStorage.setItem('musicRPG_save', JSON.stringify(saveData));
                    if (showAlert) {
                        alert('Game saved successfully!');
                    }
                } catch (error) {
                    if (showAlert) {
                        alert('Error saving game: ' + error.message);
                    }
                }
            },
            
            loadGame() {
                try {
                    const saveData = localStorage.getItem('musicRPG_save');
                    if (!saveData) {
                        alert('No save data found.');
                        return; // No save data found
                    }
                    
                    const data = JSON.parse(saveData);
                    
                    // Load achievements
                    if (data.achievements) {
                        Object.keys(data.achievements).forEach(key => {
                            if (this.achievements[key] && data.achievements[key].unlocked !== undefined) {
                                this.achievements[key].unlocked = data.achievements[key].unlocked;
                            }
                        });
                    }
                    
                    // Load character unlock status
                    if (data.characters) {
                        data.characters.forEach(savedChar => {
                            const char = this.characters.find(c => c.name === savedChar.name);
                            if (char && savedChar.unlocked !== undefined) {
                                char.unlocked = savedChar.unlocked;
                            }
                        });
                    }
                    
                    // Update displays
                    this.renderCharacterSelect();
                    this.renderAchievements();
                    
                    // Show confirmation
                    if (data.saveDate) {
                        const saveDate = new Date(data.saveDate);
                        alert('Game loaded successfully!\nSaved: ' + saveDate.toLocaleString());
                    } else {
                        alert('Game loaded successfully!');
                    }
                } catch (error) {
                    alert('Error loading game: ' + error.message);
                }
            },
            
            // Countdown timer
            updateCountdown() {
                const now = new Date();
                const diff = this.targetDate - now;
                
                if (diff <= 0) {
                    if (!this.showTimeUpMessage) {
                        this.showTimeUpMessage = true;
                        this.timeUpMessageStart = Date.now();
                        document.getElementById('timeUpMessage').style.display = 'block';
                        document.getElementById('countdown').style.display = 'none';
                    }
                    
                    const elapsed = Date.now() - this.timeUpMessageStart;
                    if (elapsed < 300000) { // 5 minutes
                        return;
                    } else {
                        this.showTimeUpMessage = false;
                        document.getElementById('timeUpMessage').style.display = 'none';
                        document.getElementById('countdown').style.display = 'block';
                    }
                    return;
                }
                
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                
                document.getElementById('countdown').textContent = 
                    `${days}d ${hours.toString().padStart(2, '0')}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s`;
            },
            
            // Screen management
            showScreen(screenName) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                document.getElementById(screenName + 'Screen').classList.add('active');
                this.currentScreen = screenName;
            },
            
            showCharacterSelect() {
                this.showScreen('characterSelect');
            },
            
            showNpcSelect() {
                this.showScreen('npcSelect');
            },
            
            showDifficultySelect() {
                this.showScreen('difficultySelect');
            },
            
            showBattle() {
                this.showScreen('battle');
                // Focus the battle screen for keyboard input
                setTimeout(() => {
                    const battleScreen = document.getElementById('battleScreen');
                    if (battleScreen) {
                        battleScreen.focus();
                    }
                }, 100);
                this.startBattle();
            },
            
            showMoveMenu() {
                if (this.playerTurn && !this.battleOver && !this.showQuestion) {
                    this.showMoveSelection = true;
                    this.selectedMoveIndex = 0;
                    this.updateBattleDisplay();
                }
            },
            
            showAchievements() {
                this.showScreen('achievements');
            },
            
            // Rendering
            renderCharacterSelect() {
                const grid = document.getElementById('characterGrid');
                grid.innerHTML = '';
                this.characters.forEach((char, i) => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    if (i === this.selectedCharacterIndex) card.classList.add('selected');
                    if (char.unlocked === false) card.classList.add('locked');
                    
                    card.innerHTML = `
                        <div style="font-size: 24px; color: ${char.color}; margin: 10px 0;">${char.name}</div>
                        <div style="font-size: 14px; color: #aaa;">
                            Spd:${char.speed} Wgt:${char.weight}<br>
                            HP:${char.base_hp} DMG:${char.base_damage}
                        </div>
                        ${char.unlocked === false ? '<div style="color: #666; margin-top: 10px;">LOCKED</div>' : ''}
                    `;
                    
                    if (char.unlocked !== false) {
                        card.onclick = () => {
                            this.selectedCharacterIndex = i;
                            this.renderCharacterSelect();
                        };
                    }
                    
                    grid.appendChild(card);
                });
            },
            
            renderNpcSelect() {
                const grid = document.getElementById('npcGrid');
                grid.innerHTML = '';
                this.characters.forEach((char, i) => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    if (i === this.selectedNpcIndex) card.classList.add('selected');
                    
                    card.innerHTML = `
                        <div style="font-size: 24px; color: ${char.color}; margin: 10px 0;">${char.name}</div>
                        <div style="font-size: 14px; color: #aaa;">
                            Spd:${char.speed} Wgt:${char.weight}<br>
                            HP:${char.base_hp} DMG:${char.base_damage}
                        </div>
                    `;
                    
                    card.onclick = () => {
                        this.selectedNpcIndex = i;
                        this.renderNpcSelect();
                    };
                    
                    grid.appendChild(card);
                });
            },
            
            renderDifficultySelect() {
                const list = document.getElementById('difficultyList');
                list.innerHTML = '';
                this.difficulties.forEach((diff, i) => {
                    const item = document.createElement('div');
                    item.className = 'difficulty-item';
                    if (i === this.selectedDifficultyIndex) item.classList.add('selected');
                    item.textContent = diff;
                    item.onclick = () => {
                        this.selectedDifficultyIndex = i;
                        this.renderDifficultySelect();
                    };
                    list.appendChild(item);
                });
            },
            
            renderAchievements() {
                const list = document.getElementById('achievementList');
                list.innerHTML = '';
                Object.values(this.achievements).forEach(ach => {
                    const item = document.createElement('li');
                    item.className = 'achievement-item';
                    if (ach.unlocked) item.classList.add('unlocked');
                    item.innerHTML = `
                        <strong>${ach.name}</strong> - ${ach.description}
                        <span style="float: right; color: ${ach.unlocked ? '#ffd700' : '#666'};">
                            ${ach.unlocked ? '✓ UNLOCKED' : 'LOCKED'}
                        </span>
                    `;
                    list.appendChild(item);
                });
            },
            
            // Battle system
            startBattle() {
                this.selectedCharacter = this.characters[this.selectedCharacterIndex];
                this.selectedDifficulty = this.difficulties[this.selectedDifficultyIndex];
                this.teacherMode = this.selectedDifficultyIndex === 4;
                this.bossRushMode = this.selectedDifficultyIndex === 5;
                
                // In Boss Rush, use the current boss instead of selected NPC
                if (this.bossRushMode) {
                    // Reset boss index if starting fresh (not continuing from previous boss)
                    if (this.currentBossIndex === 0 || !this.inBattle) {
                        this.currentBossIndex = 0;
                        // Reset player health at start of boss rush
                        this.playerHealth = this.selectedCharacter.base_hp;
                        this.playerMaxHealth = this.selectedCharacter.base_hp;
                    }
                    this.selectedNpc = this.bosses[this.currentBossIndex];
                } else {
                    this.selectedNpc = this.characters[this.selectedNpcIndex];
                    this.playerHealth = this.selectedCharacter.base_hp;
                    this.playerMaxHealth = this.selectedCharacter.base_hp;
                }
                
                if (this.teacherMode) {
                    this.teacherBattleCount = 0;
                    this.learnedPlayerPatterns = {
                        preferred_moves: {attack: 0, block: 0, super: 0},
                        move_sequences: [],
                        health_thresholds: {low: [], medium: [], high: []},
                        block_usage: 0,
                        super_usage: 0,
                    };
                }
                
                if (!this.bossRushMode) {
                    this.playerHealth = this.selectedCharacter.base_hp;
                    this.playerMaxHealth = this.selectedCharacter.base_hp;
                }
                this.npcHealth = this.selectedNpc.base_hp;
                this.npcMaxHealth = this.selectedNpc.base_hp;
                
                // In Teacher Mode, player always goes first (NPC never takes a turn)
                this.playerTurn = this.teacherMode ? true : (this.selectedCharacter.speed >= this.selectedNpc.speed);
                this.battleOver = false;
                this.battleResult = null;
                if (this.bossRushMode) {
                    this.battleMessage = `Boss Rush: Boss ${this.currentBossIndex + 1}/${this.totalBosses} - ${this.selectedNpc.name}!`;
                } else {
                    this.battleMessage = this.teacherMode ? "Teacher Mode: Battle Start! NPC is learning and won't attack." : "Battle Start!";
                }
                this.battleMessageTimer = Date.now();
                this.superMovesUsedThisBattle = 0;
                this.blocksUsed = 0;
                this.currentBattleMoves = [];
                this.playerBlocking = false;
                this.npcBlocking = false;
                this.npcMoveSelection = null;
                this.npcLastActionTime = Date.now();
                this.npcNextReactionTime = 0;
                
                // Play boss music if in boss rush mode
                if (this.bossRushMode && this.selectedNpc.musicFile) {
                    const bossMusic = document.getElementById('bossMusic');
                    if (bossMusic) {
                        bossMusic.src = this.selectedNpc.musicFile;
                        bossMusic.play().catch(e => {
                            console.log('Could not play boss music:', e);
                        });
                    }
                } else {
                    // Stop boss music if not in boss rush
                    const bossMusic = document.getElementById('bossMusic');
                    if (bossMusic) {
                        bossMusic.pause();
                        bossMusic.src = '';
                    }
                }
                
                this.updateBattleDisplay();
                this.updateBattleLoop();
            },
            
            updateBattleDisplay() {
                // Update health bars
                const playerHealthPercent = (this.playerHealth / this.playerMaxHealth) * 100;
                const npcHealthPercent = (this.npcHealth / this.npcMaxHealth) * 100;
                
                document.getElementById('playerHealth').style.width = playerHealthPercent + '%';
                document.getElementById('npcHealth').style.width = npcHealthPercent + '%';
                
                // Draw character sprites
                this.drawCharacterSprite('playerCharacter', this.selectedCharacter);
                this.drawCharacterSprite('npcCharacter', this.selectedNpc);
                
                // Update stats
                document.getElementById('playerStats').innerHTML = 
                    `<div style="font-size: 14px; margin-top: 10px;">HP: ${this.playerHealth}/${this.playerMaxHealth}</div>
                     <div style="font-size: 12px; color: #aaa;">Spd: ${this.selectedCharacter.speed} | Wgt: ${this.selectedCharacter.weight}</div>`;
                document.getElementById('npcStats').innerHTML = 
                    `<div style="font-size: 14px; margin-top: 10px;">HP: ${this.npcHealth}/${this.npcMaxHealth}</div>
                     <div style="font-size: 12px; color: #aaa;">Spd: ${this.selectedNpc.speed} | Wgt: ${this.selectedNpc.weight}</div>`;
                
                // Update battle message (hide if empty)
                const battleMessageEl = document.getElementById('battleMessage');
                battleMessageEl.textContent = this.battleMessage;
                if (this.battleMessage === "" || !this.battleMessage) {
                    battleMessageEl.style.display = 'none';
                } else {
                    battleMessageEl.style.display = 'block';
                }
                
                // Show boss rush progress indicator
                let bossRushIndicator = document.getElementById('bossRushIndicator');
                if (this.bossRushMode) {
                    if (!bossRushIndicator) {
                        bossRushIndicator = document.createElement('div');
                        bossRushIndicator.id = 'bossRushIndicator';
                        bossRushIndicator.style.cssText = 'position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 0, 0.9); padding: 10px 20px; border: 2px solid #ffd700; font-size: 16px; color: #fff; z-index: 10; border-radius: 5px; font-weight: bold;';
                        document.getElementById('battleScreen').appendChild(bossRushIndicator);
                    }
                    bossRushIndicator.textContent = `BOSS RUSH: ${this.currentBossIndex + 1}/${this.totalBosses} - ${this.selectedNpc.name}`;
                    bossRushIndicator.style.display = 'block';
                } else {
                    if (bossRushIndicator) {
                        bossRushIndicator.style.display = 'none';
                    }
                }
                
                // Show turn indicator
                let turnIndicator = document.getElementById('turnIndicator');
                if (!turnIndicator) {
                    turnIndicator = document.createElement('div');
                    turnIndicator.id = 'turnIndicator';
                    turnIndicator.style.cssText = 'position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); padding: 15px 30px; border: 2px solid #ffd700; font-size: 18px; color: #ffd700; z-index: 10; border-radius: 5px;';
                    document.getElementById('battleScreen').appendChild(turnIndicator);
                }
                
                // Show turn indicator based on current state
                if (this.battleOver) {
                    // Hide when battle is over
                    turnIndicator.style.display = 'none';
                } else if (this.showQuestion) {
                    // Hide during question
                    turnIndicator.style.display = 'none';
                } else if (this.teacherMode) {
                    // In Teacher Mode, always show player turn indicator (NPC never takes a turn)
                    if (!this.showMoveSelection) {
                        turnIndicator.textContent = 'YOUR TURN - Press SPACE or ENTER to select a move!';
                    } else {
                        turnIndicator.textContent = 'Select your move (Arrow Keys + Enter, or press 1/2/3)';
                    }
                    turnIndicator.style.display = 'block';
                } else if (this.playerTurn) {
                    // Show during player's turn
                    if (!this.showMoveSelection) {
                        turnIndicator.textContent = 'YOUR TURN - Press SPACE or ENTER to select a move!';
                    } else {
                        turnIndicator.textContent = 'Select your move (Arrow Keys + Enter, or press 1/2/3)';
                    }
                    turnIndicator.style.display = 'block';
                } else if (!this.playerTurn) {
                    // Show NPC turn
                    turnIndicator.textContent = 'NPC Turn...';
                    turnIndicator.style.display = 'block';
                } else {
                    turnIndicator.style.display = 'block'; // Default to showing
                }
                
                // Show/hide move button and menu
                const showMoveButton = document.getElementById('showMoveButton');
                if (showMoveButton) {
                    if (this.playerTurn && !this.battleOver && !this.showQuestion && !this.showMoveSelection) {
                        showMoveButton.style.display = 'block';
                    } else {
                        showMoveButton.style.display = 'none';
                    }
                }
                
                if (this.showMoveSelection && this.playerTurn && !this.battleOver && !this.showQuestion) {
                    document.getElementById('moveMenu').style.display = 'block';
                    this.renderMoveMenu();
                } else {
                    document.getElementById('moveMenu').style.display = 'none';
                }
                
                // Show/hide question overlay
                document.getElementById('questionOverlay').style.display = this.showQuestion ? 'flex' : 'none';
                
                // Show/hide win/lose overlay
                document.getElementById('winLoseOverlay').style.display = this.battleOver ? 'flex' : 'none';
                if (this.battleOver) {
                    const text = document.getElementById('winLoseText');
                    text.textContent = this.battleResult === 'win' ? 'YOU WIN!' : 'YOU LOSE!';
                    text.className = 'win-lose-text ' + (this.battleResult === 'win' ? 'win' : 'lose');
                    
                    let message = '';
                    if (this.bossRushMode) {
                        if (this.battleResult === 'win') {
                            if (this.currentBossIndex < this.totalBosses - 1) {
                                message = `Boss ${this.currentBossIndex + 1} Defeated! Press Continue for next boss...`;
                            } else {
                                message = 'Boss Rush Complete! All bosses defeated!';
                            }
                        } else {
                            message = 'Boss Rush Failed! Press Continue to return.';
                        }
                    } else if (this.teacherMode) {
                        message = `Teacher Mode: Battle ${this.teacherBattleCount + 1}/${this.teacherMaxBattles}`;
                    } else {
                        message = 'Press Continue to return to character select';
                    }
                    document.getElementById('winLoseMessage').textContent = message;
                }
            },
            
            drawCharacterSprite(containerId, character) {
                const container = document.getElementById(containerId);
                const canvas = document.createElement('canvas');
                canvas.width = 150;
                canvas.height = 200;
                canvas.style.border = '2px solid ' + character.color;
                canvas.style.background = 'rgba(0, 0, 0, 0.3)';
                canvas.style.borderRadius = '10px';
                
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Check if this is a boss and draw boss sprite
                const isBoss = this.bosses.some(boss => boss.name === character.name);
                if (isBoss) {
                    this.drawBossSprite(ctx, canvas, character);
                    container.innerHTML = '';
                    container.appendChild(canvas);
                    return;
                }
                
                const centerX = canvas.width / 2;
                const headY = 20;
                const headRadius = 12;
                
                // Draw person (white figure)
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                
                // Head
                ctx.beginPath();
                ctx.arc(centerX, headY, headRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Body (trapezoid)
                const bodyTopWidth = 25;
                const bodyBottomWidth = 30;
                const bodyHeight = 35;
                const bodyY = headY + headRadius + 3;
                
                ctx.beginPath();
                ctx.moveTo(centerX - bodyTopWidth/2, bodyY);
                ctx.lineTo(centerX + bodyTopWidth/2, bodyY);
                ctx.lineTo(centerX + bodyBottomWidth/2, bodyY + bodyHeight);
                ctx.lineTo(centerX - bodyBottomWidth/2, bodyY + bodyHeight);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Arms
                const armWidth = 6;
                const armLength = 22;
                const armY = bodyY + 8;
                
                // Left arm
                ctx.fillRect(centerX - bodyTopWidth/2 - armLength + 5, armY, armLength, armWidth);
                ctx.strokeRect(centerX - bodyTopWidth/2 - armLength + 5, armY, armLength, armWidth);
                
                // Right arm
                ctx.fillRect(centerX + bodyTopWidth/2 - 5, armY, armLength, armWidth);
                ctx.strokeRect(centerX + bodyTopWidth/2 - 5, armY, armLength, armWidth);
                
                // Legs
                const legWidth = 8;
                const legHeight = 25;
                const legY = bodyY + bodyHeight;
                
                // Left leg
                ctx.fillRect(centerX - bodyBottomWidth/2 + 6, legY, legWidth, legHeight);
                ctx.strokeRect(centerX - bodyBottomWidth/2 + 6, legY, legWidth, legHeight);
                
                // Right leg
                ctx.fillRect(centerX + bodyBottomWidth/2 - legWidth - 6, legY, legWidth, legHeight);
                ctx.strokeRect(centerX + bodyBottomWidth/2 - legWidth - 6, legY, legWidth, legHeight);
                
                // Draw instrument
                ctx.fillStyle = character.color;
                ctx.strokeStyle = '#000000';
                
                const instrumentY = armY + 3;
                const instrumentColor = character.color;
                const instrumentDark = this.darkenColor(character.color);
                
                if (character.name === 'Flute') {
                    // Flute - horizontal
                    const fluteY = instrumentY;
                    const fluteXStart = centerX - 40;
                    const fluteXEnd = centerX + 40;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(fluteXStart, fluteY);
                    ctx.lineTo(fluteXEnd, fluteY);
                    ctx.stroke();
                    // Keys
                    for (let i = 0; i < 6; i++) {
                        const keyX = fluteXStart + (i * (fluteXEnd - fluteXStart) / 6);
                        ctx.fillStyle = instrumentDark;
                        ctx.beginPath();
                        ctx.arc(keyX, fluteY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (character.name === 'Clarinet') {
                    // Clarinet - vertical
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(centerX, instrumentY);
                    ctx.lineTo(centerX, canvas.height - 5);
                    ctx.stroke();
                    // Bell
                    ctx.fillStyle = instrumentColor;
                    ctx.beginPath();
                    ctx.arc(centerX, canvas.height - 5, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (character.name === 'Saxophone') {
                    // Saxophone - curved
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 15, instrumentY + 5);
                    ctx.quadraticCurveTo(centerX, instrumentY + 20, centerX + 10, instrumentY + 35);
                    ctx.stroke();
                    // Bell
                    ctx.beginPath();
                    ctx.ellipse(centerX + 10, instrumentY + 35, 8, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (character.name === 'Trombone') {
                    // Trombone - slide
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(centerX - 4, instrumentY + 5);
                    ctx.lineTo(centerX - 4, canvas.height - 23);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + 4, instrumentY + 5);
                    ctx.lineTo(centerX + 4, canvas.height - 23);
                    ctx.stroke();
                    // Bell
                    ctx.beginPath();
                    ctx.ellipse(centerX, canvas.height - 23, 12, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (character.name === 'Baritone') {
                    // Baritone - large brass
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(centerX, instrumentY + 8);
                    ctx.lineTo(centerX, canvas.height - 30);
                    ctx.stroke();
                    // Bell
                    ctx.beginPath();
                    ctx.ellipse(centerX, canvas.height - 30, 18, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Valves
                    ctx.fillStyle = instrumentDark;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX - 8 + (i * 8), instrumentY + 23, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                } else if (character.name === 'Tuba') {
                    // Tuba - largest
                    ctx.lineWidth = 10;
                    ctx.beginPath();
                    ctx.moveTo(centerX, instrumentY - 5);
                    ctx.lineTo(centerX, canvas.height - 33);
                    ctx.stroke();
                    // Top bell
                    ctx.beginPath();
                    ctx.ellipse(centerX, instrumentY - 5, 22, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Bottom bell
                    ctx.beginPath();
                    ctx.ellipse(centerX, canvas.height - 33, 20, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (character.name === 'Mafeoso') {
                    // Mafeoso - fedora and golden saxophone
                    // Fedora
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(centerX, headY - 5, 18, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX, headY - 8, 12, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Suit
                    ctx.fillRect(centerX - 25, headY + 15, 20, 30);
                    ctx.fillRect(centerX + 5, headY + 15, 20, 30);
                    ctx.fillRect(centerX - 1, headY + 20, 2, 15);
                    
                    // Golden saxophone
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 7;
                    ctx.beginPath();
                    ctx.moveTo(centerX + 20, instrumentY + 5);
                    ctx.quadraticCurveTo(centerX + 30, instrumentY + 20, centerX + 40, instrumentY + 35);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(centerX + 40, instrumentY + 35, 10, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (character.name === 'Artful') {
                    // Artful - top hat, black and white suit, formal appearance
                    // Top hat
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(centerX, headY - 8, 16, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(centerX, headY - 12, 12, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Mask-like face (black lower face)
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 8, headY + 2, 16, 10);
                    
                    // White shirt with black tie
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 12, bodyY, 24, bodyHeight);
                    // Tie
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 2, bodyY + 5, 4, 15);
                    
                    // Black vest with buttons
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 11, bodyY + 3, 22, bodyHeight - 6);
                    // Buttons
                    ctx.fillStyle = '#cccccc';
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX, bodyY + 8 + (i * 6), 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Black sleeves/gloves
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - bodyTopWidth/2 - armLength + 5, armY, armLength, armWidth + 2);
                    ctx.fillRect(centerX + bodyTopWidth/2 - 5, armY, armLength, armWidth + 2);
                    
                    // Black trousers
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - bodyBottomWidth/2 + 6, legY, legWidth, legHeight);
                    ctx.fillRect(centerX + bodyBottomWidth/2 - legWidth - 6, legY, legWidth, legHeight);
                    
                    // Black shoes
                    ctx.fillRect(centerX - bodyBottomWidth/2 + 4, legY + legHeight, legWidth + 4, 4);
                    ctx.fillRect(centerX + bodyBottomWidth/2 - legWidth - 10, legY + legHeight, legWidth + 4, 4);
                    
                    // Cylindrical object (microphone/instrument) in left hand
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - bodyTopWidth/2 - armLength - 5, armY - 5, 6, 25);
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(centerX - bodyTopWidth/2 - armLength - 5, armY - 8, 6, 3);
                }
                
                // Character name
                ctx.fillStyle = character.color;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(character.name, centerX, canvas.height - 5);
                
                // Clear container and add canvas
                container.innerHTML = '';
                container.appendChild(canvas);
            },
            
            drawBossSprite(ctx, canvas, boss) {
                const centerX = canvas.width / 2;
                const headY = 20;
                const headRadius = 18; // Larger head for boss
                
                // Draw boss based on name
                if (boss.name === "The Shadow") {
                    // Draw checkerboard pattern function
                    const drawCheckerboard = (x, y, width, height, cellSize) => {
                        ctx.fillStyle = '#333333';
                        ctx.fillRect(x, y, width, height);
                        ctx.fillStyle = '#666666';
                        for (let i = 0; i < width; i += cellSize) {
                            for (let j = 0; j < height; j += cellSize) {
                                if ((i / cellSize + j / cellSize) % 2 === 0) {
                                    ctx.fillRect(x + i, y + j, cellSize, cellSize);
                                }
                            }
                        }
                    };
                    
                    // Thick black outline
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    
                    // Head - large round with angry expression
                    const headSize = 20;
                    drawCheckerboard(centerX - headSize, headY, headSize * 2, headSize * 2, 4);
                    ctx.strokeRect(centerX - headSize, headY, headSize * 2, headSize * 2);
                    
                    // Angry eyes - narrow horizontal slits
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 8, headY + 6, 6, 2);
                    ctx.fillRect(centerX + 2, headY + 6, 6, 2);
                    
                    // Wide open mouth with sharp teeth
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 6, headY + 14, 12, 4);
                    // Teeth
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 6; i++) {
                        ctx.fillRect(centerX - 5 + (i * 2), headY + 14, 1, 4);
                    }
                    
                    // Body - checkerboard pattern
                    const bodyY = headY + headSize * 2 + 2;
                    const bodyWidth = 30;
                    const bodyHeight = 40;
                    drawCheckerboard(centerX - bodyWidth/2, bodyY, bodyWidth, bodyHeight, 4);
                    ctx.strokeRect(centerX - bodyWidth/2, bodyY, bodyWidth, bodyHeight);
                    
                    // Arms extended - checkerboard pattern
                    const armY = bodyY + 8;
                    const armLength = 30;
                    const armWidth = 8;
                    // Left arm
                    drawCheckerboard(centerX - bodyWidth/2 - armLength, armY, armLength, armWidth, 4);
                    ctx.strokeRect(centerX - bodyWidth/2 - armLength, armY, armLength, armWidth);
                    // Right arm
                    drawCheckerboard(centerX + bodyWidth/2, armY, armLength, armWidth, 4);
                    ctx.strokeRect(centerX + bodyWidth/2, armY, armLength, armWidth);
                    
                    // Spiky hands - large bulbous fists with spikes
                    const handSize = 12;
                    // Left hand
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(centerX - bodyWidth/2 - armLength - handSize/2, armY + armWidth/2, handSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Spikes on left hand
                    ctx.fillStyle = '#000000';
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                        const spikeX = centerX - bodyWidth/2 - armLength - handSize/2 + Math.cos(angle) * (handSize + 3);
                        const spikeY = armY + armWidth/2 + Math.sin(angle) * (handSize + 3);
                        ctx.beginPath();
                        ctx.moveTo(spikeX, spikeY);
                        ctx.lineTo(spikeX + Math.cos(angle) * 4, spikeY + Math.sin(angle) * 4);
                        ctx.lineTo(spikeX + Math.cos(angle + 0.3) * 3, spikeY + Math.sin(angle + 0.3) * 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Right hand
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(centerX + bodyWidth/2 + armLength + handSize/2, armY + armWidth/2, handSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Spikes on right hand
                    ctx.fillStyle = '#000000';
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                        const spikeX = centerX + bodyWidth/2 + armLength + handSize/2 + Math.cos(angle) * (handSize + 3);
                        const spikeY = armY + armWidth/2 + Math.sin(angle) * (handSize + 3);
                        ctx.beginPath();
                        ctx.moveTo(spikeX, spikeY);
                        ctx.lineTo(spikeX + Math.cos(angle) * 4, spikeY + Math.sin(angle) * 4);
                        ctx.lineTo(spikeX + Math.cos(angle + 0.3) * 3, spikeY + Math.sin(angle + 0.3) * 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Legs - checkerboard pattern
                    const legY = bodyY + bodyHeight;
                    const legWidth = 10;
                    const legHeight = 30;
                    // Left leg
                    drawCheckerboard(centerX - bodyWidth/2 + 5, legY, legWidth, legHeight, 4);
                    ctx.strokeRect(centerX - bodyWidth/2 + 5, legY, legWidth, legHeight);
                    // Right leg
                    drawCheckerboard(centerX + bodyWidth/2 - legWidth - 5, legY, legWidth, legHeight, 4);
                    ctx.strokeRect(centerX + bodyWidth/2 - legWidth - 5, legY, legWidth, legHeight);
                    
                    // Flat boot-like feet
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - bodyWidth/2 + 3, legY + legHeight, legWidth + 4, 6);
                    ctx.fillRect(centerX + bodyWidth/2 - legWidth - 7, legY + legHeight, legWidth + 4, 6);
                    
                    // Candy necklace - colorful glowing orbs
                    const candyColors = ['#ff8800', '#ff69b4', '#ffffff', '#00ff00', '#0088ff', '#8800ff', '#ff69b4'];
                    const candyY = bodyY + 5;
                    const candySpacing = 8;
                    const candyStartX = centerX - (candyColors.length * candySpacing) / 2;
                    for (let i = 0; i < candyColors.length; i++) {
                        const candyX = candyStartX + (i * candySpacing);
                        // Glow effect
                        ctx.shadowColor = candyColors[i];
                        ctx.shadowBlur = 8;
                        // Candy orb
                        ctx.fillStyle = candyColors[i];
                        ctx.beginPath();
                        ctx.arc(candyX, candyY, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Swirl pattern inside
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(candyX, candyY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0; // Reset shadow
                } else if (boss.name === "Harken") {
                    // Harken - Yellow/orange blocky robot with glowing aura
                    const brightYellow = '#ffd700';
                    const orangeYellow = '#ff8800';
                    const darkYellow = '#cc9900';
                    
                    // Glowing aura effect - white star-like bursts behind character
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    // Draw star-like bursts
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2 / 8);
                        const burstX = centerX + Math.cos(angle) * 25;
                        const burstY = headY + 15 + Math.sin(angle) * 20;
                        ctx.beginPath();
                        for (let j = 0; j < 5; j++) {
                            const spikeAngle = angle + (j * Math.PI * 2 / 5);
                            const spikeX = burstX + Math.cos(spikeAngle) * 8;
                            const spikeY = burstY + Math.sin(spikeAngle) * 8;
                            if (j === 0) {
                                ctx.moveTo(spikeX, spikeY);
                            } else {
                                ctx.lineTo(spikeX, spikeY);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                    
                    // Head - square yellow block
                    const headSize = 18;
                    ctx.fillStyle = brightYellow;
                    ctx.fillRect(centerX - headSize/2, headY, headSize, headSize);
                    ctx.strokeStyle = darkYellow;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(centerX - headSize/2, headY, headSize, headSize);
                    
                    // Face - closed eyes with glow
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    // Downward curving line for closed eyes
                    ctx.beginPath();
                    ctx.arc(centerX, headY + 8, 6, 0, Math.PI);
                    ctx.stroke();
                    // Three vertical lines beneath (glow/lashes)
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(centerX - 2 + (i * 2), headY + 12);
                        ctx.lineTo(centerX - 2 + (i * 2), headY + 14);
                        ctx.stroke();
                    }
                    
                    // Ear-like connectors on sides
                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(centerX - headSize/2 - 4, headY + 6, 3, 6);
                    ctx.fillRect(centerX + headSize/2 + 1, headY + 6, 3, 6);
                    
                    // Torso - angular X/lightning bolt shape
                    const torsoY = headY + headSize + 2;
                    const torsoWidth = 28;
                    const torsoHeight = 35;
                    ctx.fillStyle = brightYellow;
                    ctx.beginPath();
                    // X shape
                    ctx.moveTo(centerX - torsoWidth/2, torsoY);
                    ctx.lineTo(centerX - 8, torsoY + torsoHeight/2);
                    ctx.lineTo(centerX - torsoWidth/2, torsoY + torsoHeight);
                    ctx.lineTo(centerX, torsoY + torsoHeight - 5);
                    ctx.lineTo(centerX + torsoWidth/2, torsoY + torsoHeight);
                    ctx.lineTo(centerX + 8, torsoY + torsoHeight/2);
                    ctx.lineTo(centerX + torsoWidth/2, torsoY);
                    ctx.lineTo(centerX, torsoY + 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = darkYellow;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Left arm (viewer's right) - darker orange-yellow, extended
                    const leftArmY = torsoY + 8;
                    const leftArmX = centerX - torsoWidth/2 - 15;
                    ctx.fillStyle = orangeYellow;
                    // Upper segment
                    ctx.fillRect(leftArmX, leftArmY, 12, 8);
                    ctx.strokeRect(leftArmX, leftArmY, 12, 8);
                    // Lower segment (bent forward)
                    ctx.fillRect(leftArmX + 3, leftArmY + 8, 12, 8);
                    ctx.strokeRect(leftArmX + 3, leftArmY + 8, 12, 8);
                    // Hand block
                    ctx.fillRect(leftArmX + 6, leftArmY + 16, 8, 6);
                    ctx.strokeRect(leftArmX + 6, leftArmY + 16, 8, 6);
                    
                    // Right arm (viewer's left) - lighter yellow, bent at elbow
                    const rightArmY = torsoY + 8;
                    const rightArmX = centerX + torsoWidth/2 + 3;
                    ctx.fillStyle = brightYellow;
                    // Upper segment
                    ctx.fillRect(rightArmX, rightArmY, 12, 8);
                    ctx.strokeRect(rightArmX, rightArmY, 12, 8);
                    // Elbow bend
                    ctx.fillRect(rightArmX - 4, rightArmY + 8, 8, 8);
                    ctx.strokeRect(rightArmX - 4, rightArmY + 8, 8, 8);
                    // Lower segment
                    ctx.fillRect(rightArmX - 8, rightArmY + 16, 12, 8);
                    ctx.strokeRect(rightArmX - 8, rightArmY + 16, 12, 8);
                    // Hand block
                    ctx.fillRect(rightArmX - 6, rightArmY + 24, 8, 6);
                    ctx.strokeRect(rightArmX - 6, rightArmY + 24, 8, 6);
                    
                    // Legs - stacked rectangular blocks
                    const legY = torsoY + torsoHeight;
                    const legWidth = 10;
                    
                    // Left leg (viewer's right) - two bent segments
                    ctx.fillStyle = brightYellow;
                    // Upper segment
                    ctx.fillRect(centerX - torsoWidth/2 + 5, legY, legWidth, 10);
                    ctx.strokeRect(centerX - torsoWidth/2 + 5, legY, legWidth, 10);
                    // Bent segment
                    ctx.fillRect(centerX - torsoWidth/2 + 7, legY + 10, legWidth, 10);
                    ctx.strokeRect(centerX - torsoWidth/2 + 7, legY + 10, legWidth, 10);
                    // Foot
                    ctx.fillRect(centerX - torsoWidth/2 + 5, legY + 20, legWidth + 4, 6);
                    ctx.strokeRect(centerX - torsoWidth/2 + 5, legY + 20, legWidth + 4, 6);
                    
                    // Right leg (viewer's left) - three stacked segments, tapering
                    // Upper segment
                    ctx.fillRect(centerX + torsoWidth/2 - legWidth - 5, legY, legWidth, 8);
                    ctx.strokeRect(centerX + torsoWidth/2 - legWidth - 5, legY, legWidth, 8);
                    // Middle segment (slightly narrower)
                    ctx.fillRect(centerX + torsoWidth/2 - legWidth - 3, legY + 8, legWidth - 2, 8);
                    ctx.strokeRect(centerX + torsoWidth/2 - legWidth - 3, legY + 8, legWidth - 2, 8);
                    // Lower segment (narrower)
                    ctx.fillRect(centerX + torsoWidth/2 - legWidth - 1, legY + 16, legWidth - 4, 8);
                    ctx.strokeRect(centerX + torsoWidth/2 - legWidth - 1, legY + 16, legWidth - 4, 8);
                    // Foot
                    ctx.fillRect(centerX + torsoWidth/2 - legWidth - 3, legY + 24, legWidth + 2, 6);
                    ctx.strokeRect(centerX + torsoWidth/2 - legWidth - 3, legY + 24, legWidth + 2, 6);
                } else if (boss.name === "Sans") {
                    // Sans - Skeleton in black hoodie
                    // Head - rounded skull
                    const headSize = 20;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX, headY + headSize/2, headSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Large oval eye sockets
                    ctx.fillStyle = '#000000';
                    // Left eye
                    ctx.beginPath();
                    ctx.ellipse(centerX - 5, headY + 8, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Right eye
                    ctx.beginPath();
                    ctx.ellipse(centerX + 5, headY + 8, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Small triangular nose hole
                    ctx.beginPath();
                    ctx.moveTo(centerX, headY + 12);
                    ctx.lineTo(centerX - 2, headY + 15);
                    ctx.lineTo(centerX + 2, headY + 15);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Wide permanent grin with square teeth
                    const grinY = headY + 18;
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 8, grinY, 16, 3);
                    // Square teeth
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 6; i++) {
                        ctx.fillRect(centerX - 7 + (i * 2.5), grinY, 2, 3);
                    }
                    
                    // Hoodie/jacket - black with white collar
                    const bodyY = headY + headSize + 2;
                    const bodyWidth = 28;
                    const bodyHeight = 35;
                    
                    // White inner lining/collar
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - bodyWidth/2, bodyY, bodyWidth, 8);
                    // Black main body
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - bodyWidth/2, bodyY + 8, bodyWidth, bodyHeight - 8);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(centerX - bodyWidth/2, bodyY, bodyWidth, bodyHeight);
                    
                    // Arms - black sleeves, bent at elbows (hands in pockets)
                    const armY = bodyY + 10;
                    // Left arm
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - bodyWidth/2 - 12, armY, 10, 8);
                    ctx.fillRect(centerX - bodyWidth/2 - 15, armY + 8, 8, 8);
                    // Right arm
                    ctx.fillRect(centerX + bodyWidth/2 + 2, armY, 10, 8);
                    ctx.fillRect(centerX + bodyWidth/2 + 5, armY + 8, 8, 8);
                    
                    // Black shorts
                    const shortsY = bodyY + bodyHeight;
                    ctx.fillRect(centerX - bodyWidth/2, shortsY, bodyWidth, 8);
                    
                    // Legs - black
                    const legY = shortsY + 8;
                    const legWidth = 8;
                    const legHeight = 25;
                    // Left leg
                    ctx.fillRect(centerX - bodyWidth/2 + 4, legY, legWidth, legHeight);
                    // Right leg
                    ctx.fillRect(centerX + bodyWidth/2 - legWidth - 4, legY, legWidth, legHeight);
                    
                    // White rounded feet/slippers
                    ctx.fillStyle = '#ffffff';
                    // Left foot
                    ctx.beginPath();
                    ctx.arc(centerX - bodyWidth/2 + 8, legY + legHeight, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Right foot
                    ctx.beginPath();
                    ctx.arc(centerX + bodyWidth/2 - 8, legY + legHeight, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (boss.name === "Kinito") {
                    // Kinito - Purple alien with pink tentacles and long blue legs
                    const lightPurple = '#dda0dd';
                    const vibrantPink = '#ff69b4';
                    const darkBlue = '#191970';
                    
                    // Main body - large light purple spherical shape (slightly flattened at bottom)
                    const bodyRadius = 25;
                    const bodyY = headY + 5;
                    ctx.fillStyle = lightPurple;
                    ctx.beginPath();
                    ctx.ellipse(centerX, bodyY + bodyRadius, bodyRadius, bodyRadius * 0.9, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Two wide-set white eyes
                    const eyeY = bodyY + bodyRadius - 8;
                    // Left eye
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX - 8, eyeY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Left pupil
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX - 8, eyeY, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Right eye
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX + 8, eyeY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    // Right pupil
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX + 8, eyeY, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pink spiky tentacles on upper sides (4-5 on each side)
                    const tentacleY = bodyY + 5;
                    const tentacleColors = [vibrantPink, '#ff1493', '#ff69b4', '#ff1493', vibrantPink];
                    
                    // Left side tentacles
                    for (let i = 0; i < 5; i++) {
                        const tentacleX = centerX - bodyRadius - 5;
                        const tentacleOffsetY = tentacleY + (i * 4) - 8;
                        const tentacleLength = 12 + (i * 2);
                        const angle = -0.3 + (i * 0.15); // Curving upwards and outwards
                        
                        ctx.strokeStyle = tentacleColors[i];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(tentacleX, tentacleOffsetY);
                        ctx.lineTo(
                            tentacleX + Math.cos(angle) * tentacleLength,
                            tentacleOffsetY + Math.sin(angle) * tentacleLength
                        );
                        ctx.stroke();
                        // Jagged tip
                        const tipX = tentacleX + Math.cos(angle) * tentacleLength;
                        const tipY = tentacleOffsetY + Math.sin(angle) * tentacleLength;
                        ctx.beginPath();
                        ctx.moveTo(tipX, tipY);
                        ctx.lineTo(tipX + Math.cos(angle + 0.3) * 3, tipY + Math.sin(angle + 0.3) * 3);
                        ctx.lineTo(tipX + Math.cos(angle - 0.3) * 3, tipY + Math.sin(angle - 0.3) * 3);
                        ctx.closePath();
                        ctx.fillStyle = tentacleColors[i];
                        ctx.fill();
                    }
                    
                    // Right side tentacles
                    for (let i = 0; i < 5; i++) {
                        const tentacleX = centerX + bodyRadius + 5;
                        const tentacleOffsetY = tentacleY + (i * 4) - 8;
                        const tentacleLength = 12 + (i * 2);
                        const angle = Math.PI + 0.3 - (i * 0.15); // Curving upwards and outwards
                        
                        ctx.strokeStyle = tentacleColors[i];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(tentacleX, tentacleOffsetY);
                        ctx.lineTo(
                            tentacleX + Math.cos(angle) * tentacleLength,
                            tentacleOffsetY + Math.sin(angle) * tentacleLength
                        );
                        ctx.stroke();
                        // Jagged tip
                        const tipX = tentacleX + Math.cos(angle) * tentacleLength;
                        const tipY = tentacleOffsetY + Math.sin(angle) * tentacleLength;
                        ctx.beginPath();
                        ctx.moveTo(tipX, tipY);
                        ctx.lineTo(tipX + Math.cos(angle + 0.3) * 3, tipY + Math.sin(angle + 0.3) * 3);
                        ctx.lineTo(tipX + Math.cos(angle - 0.3) * 3, tipY + Math.sin(angle - 0.3) * 3);
                        ctx.closePath();
                        ctx.fillStyle = tentacleColors[i];
                        ctx.fill();
                    }
                    
                    // Two very long, thin dark blue legs
                    const legStartY = bodyY + bodyRadius * 1.8;
                    const legLength = 50; // Very long legs
                    const legWidth = 3; // Very thin
                    
                    // Left leg
                    ctx.fillStyle = darkBlue;
                    ctx.fillRect(centerX - 6, legStartY, legWidth, legLength);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(centerX - 6, legStartY, legWidth, legLength);
                    
                    // Right leg
                    ctx.fillRect(centerX + 3, legStartY, legWidth, legLength);
                    ctx.strokeRect(centerX + 3, legStartY, legWidth, legLength);
                    
                    // Small triangular/paddle-shaped dark blue feet
                    const footY = legStartY + legLength;
                    // Left foot
                    ctx.beginPath();
                    ctx.moveTo(centerX - 6, footY);
                    ctx.lineTo(centerX - 10, footY + 4);
                    ctx.lineTo(centerX - 2, footY + 4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Right foot
                    ctx.beginPath();
                    ctx.moveTo(centerX + 6, footY);
                    ctx.lineTo(centerX + 2, footY + 4);
                    ctx.lineTo(centerX + 10, footY + 4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                
                // Boss name
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(boss.name, centerX, canvas.height - 5);
            },
            
            darkenColor(color) {
                // Convert hex to RGB and darken
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                return `rgb(${Math.floor(r * 0.7)}, ${Math.floor(g * 0.7)}, ${Math.floor(b * 0.7)})`;
            },
            
            renderMoveMenu() {
                const list = document.getElementById('moveList');
                list.innerHTML = '';
                this.moves.forEach((move, i) => {
                    const item = document.createElement('div');
                    item.className = 'move-item';
                    if (i === this.selectedMoveIndex) item.classList.add('selected');
                    item.textContent = `${i + 1}. ${move.name} - ${move.description}`;
                    item.onclick = () => {
                        this.selectedMoveIndex = i;
                        this.executePlayerMove();
                    };
                    item.onmouseenter = () => {
                        this.selectedMoveIndex = i;
                        this.renderMoveMenu();
                    };
                    list.appendChild(item);
                });
            },
            
            executePlayerMove() {
                const move = this.moves[this.selectedMoveIndex];
                this.recordPlayerMove(move.type);
                
                if (move.type === 'block') {
                    this.playerBlocking = true;
                    this.battleMessage = "";
                    this.battleMessageTimer = Date.now();
                    this.showMoveSelection = false;
                    // In Teacher Mode, NPC never takes a turn
                    if (!this.teacherMode) {
                        this.playerTurn = false;
                        this.npcLastActionTime = Date.now();
                        this.npcNextReactionTime = 0;
                    }
                    // Immediately update display to keep turn indicator visible
                    this.updateBattleDisplay();
                } else if (move.type === 'super') {
                    this.showMoveSelection = false;
                    this.showQuestion = true;
                    this.generateMusicQuestion();
                    this.questionAnswer = '';
                    document.getElementById('answerInput').value = '';
                    document.getElementById('answerInput').focus();
                    // Update display (turn indicator will be hidden during question)
                    this.updateBattleDisplay();
                } else {
                    // Normal attack
                    this.executePlayerAttack();
                    // Display will be updated in processNextHit
                }
            },
            
            executePlayerAttack() {
                const baseDamage = this.selectedCharacter.base_damage;
                const weight = this.selectedCharacter.weight;
                
                let numHits = 1;
                if (weight <= 2) {
                    numHits = Math.floor(Math.random() * 2) + 2; // 2-3 hits
                } else if (weight <= 4) {
                    numHits = Math.floor(Math.random() * 2) + 1; // 1-2 hits
                }
                
                let damagePerHit = baseDamage;
                if (numHits > 1) {
                    damagePerHit = Math.floor(damagePerHit * 0.9);
                }
                
                this.attackHits = [];
                for (let i = 0; i < numHits; i++) {
                    this.attackHits.push({
                        damage: damagePerHit,
                        hitNumber: i + 1,
                        totalHits: numHits,
                        isPlayer: true
                    });
                }
                
                this.currentHitIndex = 0;
                this.processNextHit();
            },
            
            processNextHit() {
                if (this.currentHitIndex >= this.attackHits.length) {
                    this.showMoveSelection = false;
                    // In Teacher Mode, NPC never takes a turn
                    if (!this.teacherMode) {
                        this.playerTurn = false;
                        this.npcLastActionTime = Date.now();
                        this.npcNextReactionTime = 0;
                    }
                    this.attackHits = [];
                    this.currentHitIndex = 0;
                    
                    if (this.npcHealth <= 0) {
                        this.battleOver = true;
                        this.battleResult = 'win';
                        this.battleMessage = "You Win!";
                        this.checkWinAchievements();
                    }
                    this.updateBattleDisplay();
                    return;
                }
                
                const hit = this.attackHits[this.currentHitIndex];
                
                // Check for dodge ability (like Sans)
                if (this.selectedNpc.hasDodge && this.selectedNpc.dodgeChance) {
                    const dodgeRoll = Math.random();
                    if (dodgeRoll < this.selectedNpc.dodgeChance) {
                        // Boss dodged!
                        this.battleMessage = "";
                        this.battleMessageTimer = Date.now();
                        this.currentHitIndex++;
                        if (this.currentHitIndex < this.attackHits.length) {
                            setTimeout(() => this.processNextHit(), 500);
                        } else {
                            this.showMoveSelection = false;
                            if (!this.teacherMode) {
                                this.playerTurn = false;
                                this.npcLastActionTime = Date.now();
                                this.npcNextReactionTime = 0;
                            }
                            this.attackHits = [];
                            this.currentHitIndex = 0;
                            if (this.npcHealth <= 0) {
                                this.battleOver = true;
                                this.battleResult = 'win';
                                this.battleMessage = "You Win!";
                                this.checkWinAchievements();
                            }
                        }
                        this.updateBattleDisplay();
                        return;
                    }
                    // 1% chance hit - continue with damage
                }
                
                if (this.npcBlocking) {
                    const damage = Math.max(1, Math.floor(hit.damage * 0.3));
                    this.battleMessage = "";
                    this.npcBlocking = false;
                    this.npcHealth = Math.max(0, this.npcHealth - damage);
                } else {
                    const damage = hit.damage;
                    this.battleMessage = "";
                    this.npcHealth = Math.max(0, this.npcHealth - damage);
                }
                
                this.battleMessageTimer = Date.now();
                this.currentHitIndex++;
                
                if (this.currentHitIndex < this.attackHits.length) {
                    setTimeout(() => this.processNextHit(), 500);
                } else {
                    this.showMoveSelection = false;
                    // In Teacher Mode, NPC never takes a turn - keep player turn active
                    if (!this.teacherMode) {
                        this.playerTurn = false;
                        this.npcLastActionTime = Date.now();
                        this.npcNextReactionTime = 0;
                    }
                    this.attackHits = [];
                    this.currentHitIndex = 0;
                    
                    if (this.npcHealth <= 0) {
                        this.battleOver = true;
                        this.battleResult = 'win';
                        this.battleMessage = "You Win!";
                        this.checkWinAchievements();
                    }
                    // Immediately update display to show turn indicator
                    this.updateBattleDisplay();
                }
                
                this.updateBattleDisplay();
            },
            
            submitAnswer() {
                const userAnswer = this.questionAnswer.trim().toUpperCase();
                const correctAnswer = this.currentQuestion.answer.toUpperCase();
                
                if (userAnswer === correctAnswer) {
                    // Check for dodge ability (like Sans)
                    if (this.selectedNpc.hasDodge && this.selectedNpc.dodgeChance) {
                        const dodgeRoll = Math.random();
                        if (dodgeRoll < this.selectedNpc.dodgeChance) {
                            // Boss dodged the super move!
                            this.battleMessage = "";
                            this.showQuestion = false;
                            this.currentQuestion = null;
                            this.questionAnswer = '';
                            this.battleMessageTimer = Date.now();
                            if (!this.teacherMode) {
                                this.playerTurn = false;
                                this.npcLastActionTime = Date.now();
                                this.npcNextReactionTime = 0;
                            }
                            this.updateBattleDisplay();
                            return;
                        }
                        // 1% chance hit - continue with damage
                    }
                    
                    const baseDamage = this.selectedCharacter.base_damage;
                    const damage = Math.floor(baseDamage * this.moves[2].damage_multiplier);
                    this.npcHealth = Math.max(0, this.npcHealth - damage);
                    this.battleMessage = "";
                    
                    if (this.npcHealth <= 0) {
                        this.battleOver = true;
                        this.battleResult = 'win';
                        this.battleMessage = "You Win!";
                        this.checkWinAchievements();
                    }
                } else {
                    this.battleMessage = "";
                }
                
                this.showQuestion = false;
                this.currentQuestion = null;
                this.questionAnswer = '';
                this.battleMessageTimer = Date.now();
                // In Teacher Mode, NPC never takes a turn
                if (!this.teacherMode) {
                    this.playerTurn = false;
                    this.npcLastActionTime = Date.now();
                    this.npcNextReactionTime = 0;
                }
                this.updateBattleDisplay();
            },
            
            generateMusicQuestion() {
                const clef = this.getClefForInstrument(this.selectedCharacter.name);
                const note = this.musicNotes[Math.floor(Math.random() * this.musicNotes.length)];
                const numNotes = Math.floor(Math.random() * 3) + 3; // 3-5 notes
                
                const allNotes = [];
                const availableNotes = [...this.musicNotes];
                for (let i = 0; i < numNotes; i++) {
                    const idx = Math.floor(Math.random() * availableNotes.length);
                    allNotes.push(availableNotes[idx]);
                    availableNotes.splice(idx, 1);
                }
                
                if (!allNotes.includes(note)) {
                    allNotes[Math.floor(Math.random() * allNotes.length)] = note;
                }
                
                const circledIndex = allNotes.indexOf(note);
                
                this.currentQuestion = {
                    question: "What note is circled?",
                    notes: allNotes,
                    circledIndex: circledIndex,
                    answer: note,
                    clef: clef
                };
                
                this.renderQuestion();
            },
            
            renderQuestion() {
                document.getElementById('questionText').textContent = this.currentQuestion.question;
                
                const staffContainer = document.getElementById('staffContainer');
                staffContainer.innerHTML = '';
                
                // Draw staff lines
                for (let i = 0; i < 5; i++) {
                    const line = document.createElement('div');
                    line.className = 'staff-line';
                    line.style.top = (i * 12) + 'px';
                    staffContainer.appendChild(line);
                }
                
                // Draw notes
                const noteSpacing = 500 / (this.currentQuestion.notes.length + 2);
                this.currentQuestion.notes.forEach((note, i) => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'note';
                    if (i === this.currentQuestion.circledIndex) {
                        noteEl.classList.add('circled');
                    }
                    
                    const position = this.getNotePositionOnStaff(note, this.currentQuestion.clef);
                    noteEl.style.left = (100 + i * noteSpacing) + 'px';
                    noteEl.style.top = (position * 6) + 'px';
                    
                    staffContainer.appendChild(noteEl);
                });
            },
            
            getClefForInstrument(instrumentName) {
                if (["Flute", "Clarinet", "Saxophone"].includes(instrumentName)) {
                    return "treble";
                } else if (["Tuba", "Baritone", "Trombone"].includes(instrumentName)) {
                    return "bass";
                }
                return "treble";
            },
            
            getNotePositionOnStaff(note, clef) {
                const notePositions = {
                    "C": 0, "D": 1, "E": 2, "F": 3, "G": 4, "A": 5, "B": 6
                };
                let position = notePositions[note] || 0;
                if (clef === "bass") {
                    position += 2;
                }
                return position;
            },
            
            // NPC AI
            updateBattleLoop() {
                // Always update display to keep turn indicator visible
                if (this.currentScreen === 'battle') {
                    this.updateBattleDisplay();
                }
                
                if (this.battleOver || this.showQuestion || this.currentScreen !== 'battle') {
                    setTimeout(() => this.updateBattleLoop(), 100);
                    return;
                }
                
                // Process multi-hit attacks
                if (this.attackHits.length > 0 && this.currentHitIndex < this.attackHits.length) {
                    setTimeout(() => this.updateBattleLoop(), 100);
                    return;
                }
                
                // NPC turn (skip in Teacher Mode)
                if (!this.teacherMode && !this.playerTurn && this.npcHealth > 0 && this.playerHealth > 0) {
                    const currentTime = Date.now();
                    const timeSinceTurn = currentTime - this.npcLastActionTime;
                    
                    if (this.npcNextReactionTime === 0) {
                        this.npcNextReactionTime = this.calculateNpcReactionTime();
                    }
                    
                    if (timeSinceTurn >= this.npcNextReactionTime) {
                        if (this.npcMoveSelection === null) {
                            this.npcChooseMove();
                        }
                        
                        if (this.npcMoveSelection === 'attack') {
                            this.npcExecuteAttack();
                        } else if (this.npcMoveSelection === 'block') {
                            this.npcExecuteBlock();
                        } else if (this.npcMoveSelection === 'super') {
                            this.npcExecuteSuper();
                        }
                    }
                }
                
                setTimeout(() => this.updateBattleLoop(), 100);
            },
            
            npcChooseMove() {
                if (this.teacherMode) {
                    this.npcChooseMoveTeacherMode();
                    return;
                }
                
                const difficulty = this.selectedDifficultyIndex;
                let moveWeights;
                
                if (difficulty === 0) { // Easy
                    moveWeights = [0.7, 0.2, 0.1];
                } else if (difficulty === 1) { // Medium
                    moveWeights = [0.6, 0.25, 0.15];
                } else if (difficulty === 2) { // Hard
                    moveWeights = [0.5, 0.3, 0.2];
                } else { // Expert
                    if (this.npcHealth < this.npcMaxHealth * 0.3) {
                        moveWeights = [0.4, 0.4, 0.2];
                    } else if (this.npcHealth > this.npcMaxHealth * 0.7) {
                        moveWeights = [0.4, 0.2, 0.4];
                    } else {
                        moveWeights = [0.45, 0.3, 0.25];
                    }
                }
                
                const rand = Math.random();
                if (rand < moveWeights[0]) {
                    this.npcMoveSelection = 'attack';
                } else if (rand < moveWeights[0] + moveWeights[1]) {
                    this.npcMoveSelection = 'block';
                } else {
                    this.npcMoveSelection = 'super';
                }
            },
            
            npcChooseMoveTeacherMode() {
                const totalMoves = Object.values(this.learnedPlayerPatterns.preferred_moves).reduce((a, b) => a + b, 0);
                let moveWeights;
                
                if (totalMoves === 0) {
                    moveWeights = [0.4, 0.3, 0.3];
                } else {
                    const attackPct = this.learnedPlayerPatterns.preferred_moves.attack / totalMoves;
                    const blockPct = this.learnedPlayerPatterns.preferred_moves.block / totalMoves;
                    
                    if (attackPct > 0.5) {
                        moveWeights = [0.3, 0.5, 0.2];
                    } else if (blockPct > 0.4) {
                        moveWeights = [0.6, 0.2, 0.2];
                    } else {
                        moveWeights = [0.4, 0.3, 0.3];
                    }
                }
                
                const rand = Math.random();
                if (rand < moveWeights[0]) {
                    this.npcMoveSelection = 'attack';
                } else if (rand < moveWeights[0] + moveWeights[1]) {
                    this.npcMoveSelection = 'block';
                } else {
                    this.npcMoveSelection = 'super';
                }
            },
            
            npcExecuteAttack() {
                const baseDamage = this.selectedNpc.base_damage;
                const weight = this.selectedNpc.weight;
                
                let numHits = 1;
                if (weight <= 2) {
                    numHits = Math.floor(Math.random() * 2) + 2;
                } else if (weight <= 4) {
                    numHits = Math.floor(Math.random() * 2) + 1;
                }
                
                let damagePerHit = baseDamage;
                if (numHits > 1) {
                    damagePerHit = Math.floor(damagePerHit * 0.9);
                }
                
                if (!this.checkNpcAccuracy()) {
                    this.battleMessage = "NPC attacks but misses!";
                    this.battleMessageTimer = Date.now();
                    this.playerTurn = true;
                    this.npcLastActionTime = Date.now();
                    this.npcNextReactionTime = 0;
                    this.npcMoveSelection = null;
                    this.updateBattleDisplay();
                    return;
                }
                
                this.attackHits = [];
                for (let i = 0; i < numHits; i++) {
                    this.attackHits.push({
                        damage: damagePerHit,
                        hitNumber: i + 1,
                        totalHits: numHits,
                        isNpc: true
                    });
                }
                
                this.currentHitIndex = 0;
                this.processNpcHit();
            },
            
            processNpcHit() {
                if (this.currentHitIndex >= this.attackHits.length) {
                    this.playerTurn = true;
                    this.npcLastActionTime = Date.now();
                    this.npcNextReactionTime = 0;
                    this.attackHits = [];
                    this.currentHitIndex = 0;
                    this.npcMoveSelection = null;
                    
                    if (this.playerHealth <= 0) {
                        this.battleOver = true;
                        this.battleResult = 'lose';
                        this.battleMessage = "You Lose!";
                        this.checkLoseAchievements();
                    }
                    this.updateBattleDisplay();
                    return;
                }
                
                const hit = this.attackHits[this.currentHitIndex];
                
                if (this.playerBlocking) {
                    const damage = Math.max(1, Math.floor(hit.damage * 0.3));
                    if (hit.totalHits > 1) {
                        this.battleMessage = `NPC Hit ${hit.hitNumber}/${hit.totalHits}! You block and take ${damage} damage!`;
                    } else {
                        this.battleMessage = `NPC attacks! You block and take ${damage} damage!`;
                    }
                    this.playerBlocking = false;
                    this.playerHealth = Math.max(0, this.playerHealth - damage);
                } else {
                    const damage = hit.damage;
                    if (hit.totalHits > 1) {
                        this.battleMessage = `NPC Hit ${hit.hitNumber}/${hit.totalHits}: ${damage} damage!`;
                    } else {
                        this.battleMessage = `NPC deals ${damage} damage!`;
                    }
                    this.playerHealth = Math.max(0, this.playerHealth - damage);
                }
                
                this.battleMessageTimer = Date.now();
                this.currentHitIndex++;
                
                if (this.currentHitIndex < this.attackHits.length) {
                    setTimeout(() => this.processNpcHit(), 500);
                } else {
                    this.playerTurn = true;
                    this.npcLastActionTime = Date.now();
                    this.npcNextReactionTime = 0;
                    this.attackHits = [];
                    this.currentHitIndex = 0;
                    this.npcMoveSelection = null;
                    
                    if (this.playerHealth <= 0) {
                        this.battleOver = true;
                        this.battleResult = 'lose';
                        this.battleMessage = "You Lose!";
                        this.checkLoseAchievements();
                    }
                }
                
                this.updateBattleDisplay();
            },
            
            npcExecuteBlock() {
                this.npcBlocking = true;
                this.battleMessage = "NPC prepares to block the next attack!";
                this.battleMessageTimer = Date.now();
                this.playerTurn = true;
                this.npcLastActionTime = Date.now();
                this.npcNextReactionTime = 0;
                this.npcMoveSelection = null;
                this.updateBattleDisplay();
            },
            
            npcExecuteSuper() {
                const accuracyRates = [0.5, 0.65, 0.8, 0.95];
                const npcAccuracy = accuracyRates[this.selectedDifficultyIndex];
                const isCorrect = Math.random() < npcAccuracy;
                
                if (isCorrect) {
                    const baseDamage = this.selectedNpc.base_damage;
                    const damage = Math.floor(baseDamage * this.moves[2].damage_multiplier);
                    this.playerHealth = Math.max(0, this.playerHealth - damage);
                    this.battleMessage = `NPC uses Super! Correct answer! Deals ${damage} damage!`;
                } else {
                    this.battleMessage = `NPC uses Super! Wrong answer! No damage dealt.`;
                }
                
                this.battleMessageTimer = Date.now();
                this.playerTurn = true;
                this.npcLastActionTime = Date.now();
                this.npcNextReactionTime = 0;
                this.npcMoveSelection = null;
                
                if (this.playerHealth <= 0) {
                    this.battleOver = true;
                    this.battleResult = 'lose';
                    this.battleMessage = "You Lose!";
                    this.checkLoseAchievements();
                }
                this.updateBattleDisplay();
            },
            
            calculateNpcReactionTime() {
                const baseTimes = [2500, 1750, 1250, 750];
                const variation = [500, 250, 250, 250];
                const base = baseTimes[this.selectedDifficultyIndex];
                const varAmount = Math.floor(Math.random() * variation[this.selectedDifficultyIndex] * 2) - variation[this.selectedDifficultyIndex];
                const speedModifier = (10 - this.selectedNpc.speed) * 50;
                return Math.max(300, base + varAmount - speedModifier);
            },
            
            checkNpcAccuracy() {
                const accuracyRates = [0.6, 0.75, 0.9, 1.0];
                return Math.random() < accuracyRates[this.selectedDifficultyIndex];
            },
            
            // Achievements
            recordPlayerMove(moveType) {
                if (moveType === 'super') {
                    this.superMovesUsedThisBattle++;
                }
                
                if (this.teacherMode) {
                    this.currentBattleMoves.push(moveType);
                    this.learnedPlayerPatterns.preferred_moves[moveType]++;
                    
                    const healthPercent = this.playerHealth / this.playerMaxHealth;
                    let healthLevel = 'high';
                    if (healthPercent < 0.33) healthLevel = 'low';
                    else if (healthPercent < 0.67) healthLevel = 'medium';
                    
                    this.learnedPlayerPatterns.health_thresholds[healthLevel].push(moveType);
                    
                    if (moveType === 'block') {
                        this.learnedPlayerPatterns.block_usage++;
                    } else if (moveType === 'super') {
                        this.learnedPlayerPatterns.super_usage++;
                    }
                }
            },
            
            checkWinAchievements() {
                if (!this.achievements.win.unlocked) {
                    this.achievements.win.unlocked = true;
                }
                
                if (!this.achievements.why.unlocked) {
                    this.achievements.why.unlocked = true;
                }
                
                if (!this.achievements.tune_i_love.unlocked) {
                    if (this.selectedCharacter.name === 'Saxophone') {
                        const healthPercent = this.playerHealth / this.playerMaxHealth;
                        if (healthPercent < 0.5) {
                            this.achievements.tune_i_love.unlocked = true;
                            // Unlock Mafeoso
                            const mafeoso = this.characters.find(c => c.name === 'Mafeoso');
                            if (mafeoso) mafeoso.unlocked = true;
                        }
                    }
                }
                
                if (!this.achievements.bird_plane.unlocked) {
                    if (this.superMovesUsedThisBattle === 0) {
                        this.achievements.bird_plane.unlocked = true;
                    }
                }

                // Achievement: A Good Show - win against the same instrument on Expert
                if (!this.achievements.good_show.unlocked) {
                    const isExpert = this.selectedDifficultyIndex === 3; // Expert difficulty
                    const sameInstrument = this.selectedCharacter && this.selectedNpc &&
                        this.selectedCharacter.name === this.selectedNpc.name;
                    if (isExpert && sameInstrument) {
                        this.achievements.good_show.unlocked = true;
                        // Unlock Artful character
                        const artful = this.characters.find(c => c.name === 'Artful');
                        if (artful) artful.unlocked = true;
                    }
                }
                
                this.renderAchievements();
                // Auto-save when achievements are unlocked (silent)
                this.saveGame(false);
            },
            
            checkLoseAchievements() {
                if (!this.achievements.pay_taxes.unlocked) {
                    this.achievements.pay_taxes.unlocked = true;
                }
                this.renderAchievements();
                // Auto-save when achievements are unlocked (silent)
                this.saveGame(false);
            },
            
            handleBattleEnd() {
                // Stop boss music
                const bossMusic = document.getElementById('bossMusic');
                if (bossMusic) {
                    bossMusic.pause();
                    bossMusic.src = '';
                }
                
                if (this.bossRushMode) {
                    if (this.battleResult === 'win') {
                        // Move to next boss
                        this.currentBossIndex++;
                        if (this.currentBossIndex < this.totalBosses) {
                            // Continue to next boss (player keeps current health)
                            this.inBattle = false;
                            this.battleOver = false;
                            this.battleResult = null;
                            this.showMoveSelection = false;
                            this.showQuestion = false;
                            this.playerBlocking = false;
                            this.npcBlocking = false;
                            this.npcMoveSelection = null;
                            this.npcLastActionTime = Date.now();
                            this.npcNextReactionTime = 0;
                            // Start next boss battle
                            this.startBattle();
                            return;
                        } else {
                            // All bosses defeated!
                            alert('Congratulations! You completed Boss Rush!');
                            // Return to character select
                            this.currentBossIndex = 0;
                            this.bossRushMode = false;
                        }
                    } else {
                        // Lost - reset boss rush
                        this.currentBossIndex = 0;
                        this.bossRushMode = false;
                    }
                } else if (this.teacherMode) {
                    this.teacherBattleCount++;
                    if (this.currentBattleMoves.length > 0) {
                        this.learnedPlayerPatterns.move_sequences.push([...this.currentBattleMoves]);
                    }
                    
                    if (this.teacherBattleCount < this.teacherMaxBattles) {
                        // Continue to next battle
                        this.startBattle();
                        return;
                    }
                }
                
                // Return to character select
                this.inBattle = false;
                this.battleOver = false;
                this.battleResult = null;
                this.selectedCharacter = null;
                this.selectedNpc = null;
                this.selectedDifficulty = null;
                this.teacherMode = false;
                this.teacherBattleCount = 0;
                this.bossRushMode = false;
                this.currentBossIndex = 0;
                this.showMoveSelection = false;
                this.showQuestion = false;
                this.playerBlocking = false;
                this.selectedCharacterIndex = 0;
                this.showCharacterSelect();
            },
            
            // Keyboard input
            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    if (this.currentScreen === 'characterSelect') {
                        this.handleCharacterSelectInput(e);
                    } else if (this.currentScreen === 'npcSelect') {
                        this.handleNpcSelectInput(e);
                    } else if (this.currentScreen === 'difficultySelect') {
                        this.handleDifficultySelectInput(e);
                    } else if (this.currentScreen === 'battle') {
                        this.handleBattleInput(e);
                    } else if (this.currentScreen === 'achievements') {
                        if (e.key === 'Escape') {
                            this.showScreen('title');
                        }
                    }
                });
            },
            
            handleCharacterSelectInput(e) {
                const charsPerRow = 3;
                if (e.key === 'ArrowLeft') {
                    let newIndex = (this.selectedCharacterIndex - 1 + this.characters.length) % this.characters.length;
                    while (newIndex !== this.selectedCharacterIndex && this.characters[newIndex].unlocked === false) {
                        newIndex = (newIndex - 1 + this.characters.length) % this.characters.length;
                    }
                    this.selectedCharacterIndex = newIndex;
                    this.renderCharacterSelect();
                } else if (e.key === 'ArrowRight') {
                    let newIndex = (this.selectedCharacterIndex + 1) % this.characters.length;
                    while (newIndex !== this.selectedCharacterIndex && this.characters[newIndex].unlocked === false) {
                        newIndex = (newIndex + 1) % this.characters.length;
                    }
                    this.selectedCharacterIndex = newIndex;
                    this.renderCharacterSelect();
                } else if (e.key === 'ArrowUp') {
                    let newIndex = this.selectedCharacterIndex - charsPerRow;
                    if (newIndex >= 0) {
                        while (newIndex >= 0 && this.characters[newIndex].unlocked === false) {
                            newIndex--;
                        }
                        if (newIndex >= 0) {
                            this.selectedCharacterIndex = newIndex;
                            this.renderCharacterSelect();
                        }
                    }
                } else if (e.key === 'ArrowDown') {
                    let newIndex = this.selectedCharacterIndex + charsPerRow;
                    if (newIndex < this.characters.length) {
                        while (newIndex < this.characters.length && this.characters[newIndex].unlocked === false) {
                            newIndex++;
                        }
                        if (newIndex < this.characters.length) {
                            this.selectedCharacterIndex = newIndex;
                            this.renderCharacterSelect();
                        }
                    }
                } else if (e.key === 'Enter' || e.key === ' ') {
                    if (this.characters[this.selectedCharacterIndex].unlocked !== false) {
                        this.showNpcSelect();
                    }
                } else if (e.key === 'Escape') {
                    this.showScreen('title');
                }
            },
            
            handleNpcSelectInput(e) {
                const charsPerRow = 3;
                if (e.key === 'ArrowLeft') {
                    this.selectedNpcIndex = (this.selectedNpcIndex - 1 + this.characters.length) % this.characters.length;
                    this.renderNpcSelect();
                } else if (e.key === 'ArrowRight') {
                    this.selectedNpcIndex = (this.selectedNpcIndex + 1) % this.characters.length;
                    this.renderNpcSelect();
                } else if (e.key === 'ArrowUp') {
                    const newIndex = this.selectedNpcIndex - charsPerRow;
                    if (newIndex >= 0) {
                        this.selectedNpcIndex = newIndex;
                        this.renderNpcSelect();
                    }
                } else if (e.key === 'ArrowDown') {
                    const newIndex = this.selectedNpcIndex + charsPerRow;
                    if (newIndex < this.characters.length) {
                        this.selectedNpcIndex = newIndex;
                        this.renderNpcSelect();
                    }
                } else if (e.key === 'Enter' || e.key === ' ') {
                    this.showDifficultySelect();
                } else if (e.key === 'Escape') {
                    this.showCharacterSelect();
                }
            },
            
            handleDifficultySelectInput(e) {
                if (e.key === 'ArrowUp') {
                    this.selectedDifficultyIndex = (this.selectedDifficultyIndex - 1 + this.difficulties.length) % this.difficulties.length;
                    this.renderDifficultySelect();
                } else if (e.key === 'ArrowDown') {
                    this.selectedDifficultyIndex = (this.selectedDifficultyIndex + 1) % this.difficulties.length;
                    this.renderDifficultySelect();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    this.showBattle();
                } else if (e.key === 'Escape') {
                    this.showNpcSelect();
                }
            },
            
            handleBattleInput(e) {
                // Prevent default for game keys
                if ([' ', 'Enter', 'ArrowUp', 'ArrowDown', '1', '2', '3', 'Escape'].includes(e.key)) {
                    e.preventDefault();
                }
                
                if (this.battleOver) {
                    if (e.key === 'Enter') {
                        this.handleBattleEnd();
                    }
                    return;
                }
                
                if (this.showQuestion) {
                    if (e.key === 'Enter') {
                        this.submitAnswer();
                    } else if (e.key === 'Backspace') {
                        this.questionAnswer = this.questionAnswer.slice(0, -1);
                        document.getElementById('answerInput').value = this.questionAnswer;
                    } else if (e.key.length === 1 && /[A-Za-z0-9#]/.test(e.key)) {
                        this.questionAnswer += e.key.toUpperCase();
                        document.getElementById('answerInput').value = this.questionAnswer;
                    }
                    return;
                }
                
                if (this.playerTurn && !this.battleOver) {
                    if (!this.showMoveSelection) {
                        // Show move menu on any key press during player turn
                        if (e.key === ' ' || e.key === 'Enter' || e.key === '1' || e.key === '2' || e.key === '3') {
                            this.showMoveSelection = true;
                            this.selectedMoveIndex = 0;
                            this.updateBattleDisplay();
                        }
                    } else {
                        if (e.key === 'ArrowUp') {
                            this.selectedMoveIndex = (this.selectedMoveIndex - 1 + this.moves.length) % this.moves.length;
                            this.updateBattleDisplay();
                        } else if (e.key === 'ArrowDown') {
                            this.selectedMoveIndex = (this.selectedMoveIndex + 1) % this.moves.length;
                            this.updateBattleDisplay();
                        } else if (e.key === '1') {
                            this.selectedMoveIndex = 0;
                            this.executePlayerMove();
                        } else if (e.key === '2') {
                            this.selectedMoveIndex = 1;
                            this.executePlayerMove();
                        } else if (e.key === '3') {
                            this.selectedMoveIndex = 2;
                            this.executePlayerMove();
                        } else if (e.key === 'Enter' || e.key === ' ') {
                            this.executePlayerMove();
                        } else if (e.key === 'Escape') {
                            this.showMoveSelection = false;
                            this.updateBattleDisplay();
                        }
                    }
                }
            }
        };
        
        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html>